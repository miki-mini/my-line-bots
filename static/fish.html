<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç´„É©„Éï„É´„ÅäÈ≠ö„ÅÆ„ÅäÈÉ®Â±ãÊ∞¥ÊóèÈ§® - Fish Room Aquarium (3D)</title>
    <!-- MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            /* Dark background for video */
            font-family: 'Arial', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 10;
            text-align: center;
            text-shadow: 0 0 5px black;
        }

        .hide {
            display: none !important;
        }

        video {
            display: none;
            /* Hidden, rendered to texture or behind canvas */
        }

        /* Video background if not using texture */
        #bg-video {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            z-index: 0;
            transform: scaleX(-1);
            /* Mirror effect */
            filter: blur(4px) brightness(0.8);
        }
    </style>
</head>

<body>
    <div id="loading">üêü 3DÊ∞¥ÊóèÈ§®„ÇíÊ∫ñÂÇô‰∏≠...<br><span style="font-size:16px">„Ç´„É°„É©„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</span></div>

    <!-- Background Video Element (Rendered via CSS for performance/AR feel) -->
    <video class="input_video" id="bg-video" playsinline autoplay muted></video>

    <!-- Three.js Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Corner Decorations (Overlay) -->
    <img src="/static/images/fish/hidarisita.png"
        style="position: absolute; bottom: 0; left: 0; width: 350px; max-width: 40%; z-index: 5; pointer-events: none;"
        alt="decoration-left">
    <img src="/static/images/fish/migisita.png"
        style="position: absolute; bottom: 0; right: 0; width: 350px; max-width: 40%; z-index: 5; pointer-events: none;"
        alt="decoration-right">

    <script>
        // ==========================================
        // Constants & Setup
        // ==========================================
        const container = document.getElementById('canvas-container');
        const loadingElement = document.getElementById('loading');
        const videoElement = document.querySelector('.input_video');

        // Three.js Globals
        let scene, camera, renderer;
        let width, height;
        let clock = new THREE.Clock();

        // Game Objects
        const fishes = [];
        const bubbles = [];
        const rareAnimals = [];
        const effects = [];
        const foods = [];
        const ripples = [];
        const eggs = [];
        let shark = null;
        let lastFoodTime = 0;

        // Constants
        const NUM_FISH = 80; // Increased for 3D
        const WORLD_DEPTH = 800;
        const WORLD_WIDTH = 1200;
        const WORLD_HEIGHT = 800;

        const SHARK_SPAWN_INTERVAL = 10000;
        let lastSharkTime = 0;

        // MediaPipe
        let handLandmarks = [];
        let isHandPresent = false;
        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Hand Velocity Tracking
        let prevHandPixelPos = null;
        let handSpeed = 0;


        // Audio
        let audioCtx;
        let bgm = null;

        // ==========================================
        // Assets Loading
        // ==========================================
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            shark: textureLoader.load('/static/images/fish/shark.png'),
            turtle: textureLoader.load('/static/images/fish/turtle.png'),
            turtleKira: textureLoader.load('/static/images/fish/turtle.kirakira.png'),
            octopus: textureLoader.load('/static/images/fish/octopus.png'),
            octopusSumi: textureLoader.load('/static/images/fish/octopus.sumi.png'),
        };

        // Create Fish Texture Canvas Programmatically for variety
        function createFishTexture(hue) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const color = `hsl(${hue}, 80%, 60%)`;

            // Draw fish
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(100, 32);
            ctx.lineTo(20, 10);
            ctx.lineTo(20, 54);
            ctx.closePath();
            ctx.fill();

            // Tail
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.moveTo(20, 32);
            ctx.lineTo(0, 10);
            ctx.lineTo(0, 54);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(80, 25, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(82, 25, 2, 0, Math.PI * 2);
            ctx.fill();

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }


        // ==========================================
        // Three.js Initialization
        // ==========================================
        function initThree() {
            width = window.innerWidth;
            height = window.innerHeight;

            scene = new THREE.Scene();
            // Fog for depth
            scene.fog = new THREE.FogExp2(0x001020, 0.0015);

            // Camera
            camera = new THREE.PerspectiveCamera(60, width / height, 1, 2000);
            camera.position.z = 600;

            // Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(0, 500, 200);
            scene.add(dirLight);

            // Water Particles (plankton/dust)
            const particlesGeometry = new THREE.BufferGeometry();
            const particleCount = 200;
            const posArray = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 2000;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const material = new THREE.PointsMaterial({
                size: 3,
                color: 0x88ccff,
                transparent: true,
                opacity: 0.4
            });
            const particlesMesh = new THREE.Points(particlesGeometry, material);
            scene.add(particlesMesh);

            window.addEventListener('resize', onWindowResize, false);

            initFishes();
            animate();
        }

        function onWindowResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // ==========================================
        // Logic Classes
        // ==========================================

        class Vector3D {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            add(v) { this.x += v.x; this.y += v.y; this.z += v.z; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; this.z -= v.z; return this; }
            mult(n) { this.x *= n; this.y *= n; this.z *= n; return this; }
            div(n) { if (n !== 0) { this.x /= n; this.y /= n; this.z /= n; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
            normalize() {
                const m = this.mag();
                if (m !== 0) this.div(m);
                return this;
            }
            limit(max) {
                if (this.mag() > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }
            static dist(v1, v2) {
                return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2 + (v1.z - v2.z) ** 2);
            }
            copy() { return new Vector3D(this.x, this.y, this.z); }
            toThree() { return new THREE.Vector3(this.x, this.y, this.z); }
        }

        class Fish3D {
            constructor() {
                this.pos = new Vector3D(
                    (Math.random() - 0.5) * WORLD_WIDTH,
                    (Math.random() - 0.5) * WORLD_HEIGHT,
                    (Math.random() - 0.5) * WORLD_DEPTH
                );
                this.vel = new Vector3D(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
                this.acc = new Vector3D(0, 0, 0);

                this.maxSpeed = 3 + Math.random() * 2;
                this.maxForce = 0.1;
                this.baseSize = 15 + Math.random() * 15;
                this.currentSize = this.baseSize;
                this.age = 1.0;

                // Mesh
                // Normalized geometry, scaled by instance
                const geometry = new THREE.PlaneGeometry(1, 0.5);
                const hue = Math.random() * 360;
                const texture = createFishTexture(hue);

                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.updateSize();
                scene.add(this.mesh);
            }

            updateSize() {
                // Aspect ratio 2:1
                this.mesh.scale.set(this.currentSize * 2, this.currentSize, 1);
            }

            flock(boids) {
                let sep = this.separate(boids);
                let ali = this.align(boids);
                let coh = this.cohesion(boids);

                sep.mult(1.5);
                ali.mult(1.0);
                coh.mult(1.0);

                this.applyForce(sep);
                this.applyForce(ali);
                this.applyForce(coh);

                // Food Attraction
                let foodForce = this.seekFood(foods);
                this.applyForce(foodForce);

                // Shark Avoidance
                if (shark) {
                    let sharkPos = new Vector3D(shark.mesh.position.x, shark.mesh.position.y, shark.mesh.position.z);
                    let flee = this.flee(sharkPos);
                    flee.mult(5.0);
                    this.applyForce(flee);
                }

                // Hand Attraction
                if (isHandPresent && handLandmarks.length > 0) {
                    // Hand is 2D, project to 3D roughly
                    // Use specific Z plane for hand interaction? e.g., z=0
                    // Mapping 0..1 to WorldCoords
                    let hx = (handLandmarks[0][8].x - 0.5) * WORLD_WIDTH; // Mirror? Hand logic needs check
                    let hy = -(handLandmarks[0][8].y - 0.5) * WORLD_HEIGHT; // Flip Y
                    let hz = 100; // Hand is "forward"

                    // Correction for mirror mode
                    hx = -hx;

                    let target = new Vector3D(hx, hy, hz);
                    let seek = this.seek(target);
                    seek.mult(2.0);
                    this.applyForce(seek);
                }
            }

            flee(target) {
                let desired = this.pos.copy().sub(target); // Away from target
                let d = desired.mag();
                if (d < 300) {
                    desired.normalize();
                    desired.mult(this.maxSpeed);
                    let steer = desired.sub(this.vel);
                    steer.limit(this.maxForce);
                    return steer;
                }
                return new Vector3D(0, 0, 0);
            }

            seek(target) {
                let desired = target.copy().sub(this.pos);
                desired.normalize();
                desired.mult(this.maxSpeed);
                let steer = desired.sub(this.vel);
                steer.limit(this.maxForce);
                return steer;
            }

            separate(boids) {
                let desiredseparation = 60.0;
                let steer = new Vector3D(0, 0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector3D.dist(this.pos, other.pos);
                    if ((d > 0) && (d < desiredseparation)) {
                        let diff = this.pos.copy().sub(other.pos);
                        diff.normalize();
                        diff.div(d);
                        steer.add(diff);
                        count++;
                    }
                }
                if (count > 0) {
                    steer.div(count);
                }
                if (steer.mag() > 0) {
                    steer.normalize();
                    steer.mult(this.maxSpeed);
                    steer.sub(this.vel);
                    steer.limit(this.maxForce);
                }
                return steer;
            }

            align(boids) {
                let neighbordist = 100;
                let sum = new Vector3D(0, 0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector3D.dist(this.pos, other.pos);
                    if ((d > 0) && (d < neighbordist)) {
                        sum.add(other.vel);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.div(count);
                    sum.normalize();
                    sum.mult(this.maxSpeed);
                    let steer = sum.sub(this.vel);
                    steer.limit(this.maxForce);
                    return steer;
                }
                return new Vector3D(0, 0, 0);
            }

            cohesion(boids) {
                let neighbordist = 100;
                let sum = new Vector3D(0, 0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector3D.dist(this.pos, other.pos);
                    if ((d > 0) && (d < neighbordist)) {
                        sum.add(other.pos);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.div(count);
                    return this.seek(sum);
                }
                return new Vector3D(0, 0, 0);
            }

            seekFood(foods) {
                let closest = null;
                let minDist = 300; // Perception radius for food

                for (let food of foods) {
                    let d = Vector3D.dist(this.pos, food.pos);
                    if (d < minDist) {
                        minDist = d;
                        closest = food;
                    }
                }

                if (closest) {
                    // Check if close enough to eat
                    if (minDist < 20) {
                        closest.eaten = true;
                        // Grow
                        this.currentSize += 2.0;
                        if (this.currentSize > this.baseSize * 2.5) this.currentSize = this.baseSize * 2.5;
                        this.updateSize();
                        playSound('pop');
                        return new Vector3D(0, 0, 0);
                    }

                    let seekForce = this.seek(closest.pos);
                    seekForce.mult(2.0); // Strong attraction
                    return seekForce;
                }
                return new Vector3D(0, 0, 0);
            }

            update() {
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
                this.edges();

                // Update Mesh
                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                // Rotation (Look at velocity direction)
                // atan2 for 2D, but lookAt for 3D is easier
                let lookTarget = this.mesh.position.clone().add(this.vel.toThree());
                this.mesh.lookAt(lookTarget);
                // Fix orientation (planes face +Z by default, fish texture points right?)
                // If fish texture points right (common), strict lookAt aligns -Z axis.
                // We might need to rotate geometry or adjust.
                // Let's assume lookAt works for now, might be upside down or sideways.
                // Actually lookAt makes +Z point to target. Plane is XY.
                // We'll see.
            }

            applyForce(force) {
                this.acc.add(force);
            }

            edges() {
                const W = WORLD_WIDTH / 2 + 100;
                const H = WORLD_HEIGHT / 2 + 100;
                const D = WORLD_DEPTH / 2 + 100;

                if (this.pos.x < -W) this.pos.x = W;
                if (this.pos.y < -H) this.pos.y = H;
                if (this.pos.z < -D) this.pos.z = D;

                if (this.pos.x > W) this.pos.x = -W;
                if (this.pos.y > H) this.pos.y = -H;
                if (this.pos.z > D) this.pos.z = -D;
            }

            seekFood(foods) {
                let closest = null;
                let minDist = 300; // Perception radius for food

                for (let food of foods) {
                    let d = Vector3D.dist(this.pos, food.pos);
                    if (d < minDist) {
                        minDist = d;
                        closest = food;
                    }
                }

                if (closest) {
                    // Check if close enough to eat
                    if (minDist < 20) {
                        closest.eaten = true;
                        // Grow? (Next phase)
                        return new Vector3D(0, 0, 0);
                    }

                    let seekForce = this.seek(closest.pos);
                    seekForce.mult(2.0); // Strong attraction
                    return seekForce;
                }
                return new Vector3D(0, 0, 0);
            }
        }

        // ü¶à Shark 3D
        class Shark3D {
            constructor() {
                // Start far left or right
                this.pos = new Vector3D(-WORLD_WIDTH / 2 - 200, 0, 0);
                this.vel = new Vector3D(5, 0, 0);
                this.size = 200;

                const geometry = new THREE.PlaneGeometry(this.size * 2, this.size);
                const material = new THREE.MeshBasicMaterial({
                    map: textures.shark,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);

                // Keep upright?
                // We want shark to face movement.
                this.fleeing = false;
            }

            update() {
                this.pos.add(this.vel);
                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                // Simple facing
                if (this.vel.x > 0) {
                    this.mesh.rotation.y = 0; // Face right
                    // My textures usually point left or right. Assuming Left?
                    // If texture points left, scaling x = -1 flips it.
                    // Let's assume texture points left (standard in my prev code?).
                    // Yes, prev code used `scale(-1, 1)` when vel.x < 0.
                    // This means default (scale 1) is facing Left.
                    // So if moving Right (vel > 0), we need scale -1 (or rotation PI).
                    this.mesh.scale.x = -1;
                } else {
                    this.mesh.scale.x = 1;
                }

                if (this.pos.x > WORLD_WIDTH / 2 + 400 && !this.fleeing) return true;

                if (this.fleeing) {
                    this.vel.x += (this.vel.x > 0 ? 0.5 : -0.5); // Accelerate
                    if (this.pos.x > WORLD_WIDTH / 2 + 500 || this.pos.x < -WORLD_WIDTH / 2 - 500) return true;
                }

                return false;
            }

            checkRepel(handPos, handSpeed) {
                if (!handPos) return;

                // Use screen space overlap for "touching" the shark
                if (checkScreenOverlap(this.mesh, handPos.x, handPos.y)) {
                    if (handSpeed > 20) { // Fast movement threshold
                        this.fleeing = true;
                        this.vel.x *= -1.5; // Turn/Accelerate
                        playSound('shark');
                    }
                }
            }
        }


        // Generate Sparkle Texture
        function createSparkleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Glow
            const cx = 32, cy = 32;
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 220, 100, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);

            // Star shape
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(32, 0); ctx.lineTo(36, 28); ctx.lineTo(64, 32); ctx.lineTo(36, 36);
            ctx.lineTo(32, 64); ctx.lineTo(28, 36); ctx.lineTo(0, 32); ctx.lineTo(28, 28);
            ctx.closePath();
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }
        const sparkleTexture = createSparkleTexture();

        // ==========================================
        // Effects
        // ==========================================
        class ParticleSystem {
            constructor(x, y, z, type) {
                this.particles = [];
                this.type = type;
                const count = type === 'ink' ? 20 : 20; // More sparkles
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);

                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        vel: new THREE.Vector3((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5),
                        life: 1.0
                    });
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const color = type === 'ink' ? 0x000000 : 0xFFFFFF; // White tint for texture
                const size = type === 'ink' ? 80 : 40; // Larger for texture

                // Use texture for ink if available
                let map = null;
                let blending = THREE.NormalBlending;
                let depthWrite = true;

                if (type === 'ink') {
                    map = textures.octopusSumi;
                } else if (type === 'sparkle') {
                    map = sparkleTexture;
                    blending = THREE.AdditiveBlending;
                    depthWrite = false;
                }

                const material = new THREE.PointsMaterial({
                    color: color,
                    size: size,
                    transparent: true,
                    opacity: 1.0,
                    map: map,
                    blending: blending,
                    depthWrite: depthWrite,
                    sizeAttenuation: true,
                    alphaTest: 0.01
                });

                this.mesh = new THREE.Points(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                const positions = this.mesh.geometry.attributes.position.array;
                let alive = false;

                for (let i = 0; i < this.particles.length; i++) {
                    let p = this.particles[i];
                    if (p.life > 0) {
                        positions[i * 3] += p.vel.x;
                        positions[i * 3 + 1] += p.vel.y;
                        positions[i * 3 + 2] += p.vel.z;
                        p.life -= 0.02;
                        alive = true;
                    }
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
                this.mesh.material.opacity -= 0.01;

                return !alive || this.mesh.material.opacity <= 0;
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // üêô Octopus 3D
        class Octopus3D {
            constructor() {
                this.pos = new Vector3D(
                    (Math.random() - 0.5) * WORLD_WIDTH * 0.8,
                    -WORLD_HEIGHT / 2 - 100,
                    (Math.random() - 0.5) * WORLD_DEPTH
                );
                this.vel = new Vector3D(0, 1.0, 0); // Up
                this.size = 120;
                this.wobble = Math.random() * 100;
                this.inked = false;

                const geometry = new THREE.PlaneGeometry(this.size, this.size);
                const material = new THREE.MeshBasicMaterial({
                    map: textures.octopus,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                this.pos.add(this.vel);
                this.wobble += 0.05;
                this.pos.x += Math.sin(this.wobble) * 2;

                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);
                this.mesh.lookAt(camera.position);

                if (this.pos.y > WORLD_HEIGHT / 2 + 100) return true;
                return false;
            }

            spawnInk() {
                effects.push(new ParticleSystem(this.pos.x, this.pos.y, this.pos.z, 'ink'));
            }
        }

        // üê¢ Turtle 3D
        class Turtle3D {
            constructor() {
                this.pos = new Vector3D(WORLD_WIDTH / 2 + 200, (Math.random() - 0.5) * WORLD_HEIGHT * 0.5, (Math.random() - 0.5) * 500);
                this.vel = new Vector3D(-1.5, 0, 0);
                this.size = 140;
                this.paddle = 0;
                this.sparkling = false;

                const geometry = new THREE.PlaneGeometry(this.size, this.size);
                const material = new THREE.MeshBasicMaterial({
                    map: textures.turtle,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                this.pos.add(this.vel);
                this.paddle += 0.1;

                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                this.mesh.rotation.z = Math.sin(this.paddle) * 0.1;
                this.mesh.rotation.y = 0;

                // Texture Swap Logic
                if (this.sparkling) {
                    this.mesh.material.map = textures.turtleKira;
                }

                if (this.pos.x < -WORLD_WIDTH / 2 - 200) return true;
                return false;
            }

            spawnSparkle() {
                effects.push(new ParticleSystem(this.pos.x, this.pos.y, this.pos.z, 'sparkle'));
            }
        }

        // ü´ß Bubble 3D
        class Bubble3D {
            constructor() {
                this.pos = new Vector3D(
                    (Math.random() - 0.5) * WORLD_WIDTH,
                    -WORLD_HEIGHT / 2 - 50,
                    (Math.random() - 0.5) * WORLD_DEPTH
                );
                this.vel = new Vector3D(0, 1 + Math.random() * 2, 0);
                this.radius = 10 + Math.random() * 20;

                // Sphere Geometry for bubbles
                const geometry = new THREE.SphereGeometry(this.radius, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    shininess: 100,
                    specular: 0xffffff
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                this.pos.add(this.vel);
                this.pos.x += Math.sin(this.pos.y * 0.05) * 0.5;

                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                if (this.pos.y > WORLD_HEIGHT / 2 + 100) return true;
                return false;
            }

            pop() {
                scene.remove(this.mesh);
                // Particle effect TBD
                playSound('pop');
            }
        }

        // üçû Food 3D
        class Food3D {
            constructor(x, y, z) {
                this.pos = new Vector3D(x, y, z);
                this.vel = new Vector3D(0, -2, 0); // Falls down
                this.eaten = false;

                const geometry = new THREE.SphereGeometry(5, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                this.pos.add(this.vel);
                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                if (this.pos.y < -WORLD_HEIGHT / 2 - 50) return true; // Removed if out of bounds
                return this.eaten;
            }
        }

        // üíß Ripple Effect (Simple Ring)
        class Ripple {
            constructor(x, y, z) {
                this.pos = new Vector3D(x, y, z);
                this.life = 1.0;

                const geometry = new THREE.RingGeometry(1, 2, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(x, y, z);
                this.mesh.rotation.x = 0; // Face camera? Or Flat?
                // If we want it to look like "water surface" it should be somewhat vertical or following screen?
                // Since it's an AR feel, flat against screen (XY plane) is best.
                scene.add(this.mesh);
            }

            update() {
                this.life -= 0.02;
                const scale = 1.0 + (1.0 - this.life) * 50; // Expand
                this.mesh.scale.set(scale, scale, 1);
                this.mesh.material.opacity = this.life * 0.5;

                if (this.life <= 0) return true;
                return false;
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // ... Existing initFishes ...
        // ü•ö Egg 3D
        class Egg3D {
            constructor() {
                this.pos = new Vector3D(
                    (Math.random() - 0.5) * WORLD_WIDTH * 0.8,
                    WORLD_HEIGHT / 2 + 50, // Start above
                    0
                );
                this.vel = new Vector3D(0, -0.5, 0); // Sink slowly
                this.incubation = 0;
                this.hatched = false;

                const geometry = new THREE.SphereGeometry(8, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: 0xffffee });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                this.pos.add(this.vel);
                // Wobbly fall
                this.pos.x += Math.sin(this.pos.y * 0.02) * 0.5;

                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                // Bottom check? Or just float forever until hatched/despawn
                if (this.pos.y < -WORLD_HEIGHT / 2 - 100) return true;
                return this.hatched;
            }

            checkWarmth(handPos) {
                if (!handPos) return;
                // Check screen distance
                if (checkScreenOverlap(this.mesh, handPos.x, handPos.y)) {
                    this.incubation += 1;
                    this.mesh.material.color.setHex(0xffaaaa); // Warm color
                    if (this.incubation > 60) { // ~1 sec
                        this.hatch();
                    }
                } else {
                    this.mesh.material.color.setHex(0xffffee);
                }
            }

            hatch() {
                this.hatched = true;
                scene.remove(this.mesh);
                // Spawn Baby Fish
                let baby = new Fish3D();
                baby.pos = this.pos.copy();
                baby.baseSize = 10;
                baby.currentSize = 5; // Tiny
                baby.updateSize();
                fishes.push(baby);

                // Effect
                playSound('magic');
                effects.push(new ParticleSystem(this.pos.x, this.pos.y, this.pos.z, 'sparkle'));
            }
        }

        function initFishes() {
            for (let i = 0; i < NUM_FISH; i++) {
                fishes.push(new Fish3D());
            }
            // Start Animation Loop
            initAudio();
        }

        // ==========================================
        // Interaction Helper
        // ==========================================
        function checkScreenOverlap(mesh, cx, cy) {
            if (!mesh) return false;
            // Project 3D position to 2D screen space
            const vector = mesh.position.clone();
            vector.project(camera);

            const x = (vector.x * .5 + .5) * width;
            const y = (1 - (vector.y * .5 + .5)) * height;

            const dx = x - cx;
            const dy = y - cy;
            const d = Math.sqrt(dx * dx + dy * dy);

            return d < 80; // 80px radius interaction
        }

        function animate() {
            requestAnimationFrame(animate);

            // Hand Position in Pixels
            let handPixelPos = null;
            if (isHandPresent && handLandmarks.length > 0) {
                // MediaPipe x is 0..1 (Left..Right of image)
                let lx = handLandmarks[0][8].x;
                let ly = handLandmarks[0][8].y;

                // If we flip the video visually with css scaleX(-1),
                // we must flip the coordinate to match visual screen position.
                let sx = (1 - lx) * width;
                let sy = ly * height;

                if (prevHandPixelPos) {
                    const dx = sx - prevHandPixelPos.x;
                    const dy = sy - prevHandPixelPos.y;
                    handSpeed = Math.sqrt(dx * dx + dy * dy);
                }
                prevHandPixelPos = { x: sx, y: sy };
                handPixelPos = { x: sx, y: sy };
            } else {
                prevHandPixelPos = null;
                handSpeed = 0;
            }

            // Ripple Trigger
            if (handPixelPos && handSpeed > 15) { // Threshold for ripple
                if (Math.random() < 0.3) {
                    let rx = (handPixelPos.x / width - 0.5) * WORLD_WIDTH;
                    let ry = -(handPixelPos.y / height - 0.5) * WORLD_HEIGHT;
                    effects.push(new Ripple(rx, ry, 0));
                }
            } else if (handPixelPos) {
                // Magic Hand Particles (Sparkles when moving slowly)
                if (Math.random() < 0.2) {
                    let hx = (handPixelPos.x / width - 0.5) * WORLD_WIDTH;
                    let hy = -(handPixelPos.y / height - 0.5) * WORLD_HEIGHT;
                    // Add random offset
                    hx += (Math.random() - 0.5) * 20;
                    hy += (Math.random() - 0.5) * 20;
                    effects.push(new ParticleSystem(hx, hy, 0, 'sparkle'));
                }
            }

            // Fish
            for (let fish of fishes) {
                fish.flock(fishes); // Includes seekFood logic now
                fish.update();
            }

            // Food Logic
            // Pinch Detection (Thumb 4 and Index 8)
            if (isHandPresent && handLandmarks.length > 0) {
                let p1 = handLandmarks[0][4]; // Thumb
                let p2 = handLandmarks[0][8]; // Index

                // Calculate distance (approx in screen space relative units)
                let dx = p1.x - p2.x;
                let dy = p1.y - p2.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                // DEBUG: console.log(dist); // Approx 0.05 is close
                if (dist < 0.05) {
                    const now = Date.now();
                    if (now - lastFoodTime > 200) { // Cooldown
                        // Spawn food at index finger position
                        // Map standard 0..1 to World
                        let hx = (1 - p2.x) * width; // Screen pixels
                        let hy = p2.y * height;

                        // We need World Coords for the food.
                        // Simple mapping since our camera is fixed
                        // Or use unproject if accurate, but linear mapping is fine here.
                        // Center (width/2, height/2) -> (0,0)

                        let wx = (hx - width / 2); // Very rough, but camera is perspective.
                        // Actually our World W/H is approx 1200/800.
                        // Let's use the same mapping as hand PixelPos logic but centered.

                        // let lx = p2.x; (0..1)
                        // worldX = (0.5 - lx) * WORLD_WIDTH (if no mirror)
                        // With mirror scaleX(-1) on video...
                        // Let's use the visual position we calculated for handPixelPos

                        if (handPixelPos) {
                            // handPixelPos is Screen Coords (0..width, 0..height)
                            // Map Screen to World
                            // Screen Center is (width/2, height/2) -> World (0,0)
                            // Scale factor?
                            // At z=0, visible height is bounded by FOV using trig, but let's approximate.

                            let logicX = (handPixelPos.x / width - 0.5) * WORLD_WIDTH;
                            let logicY = -(handPixelPos.y / height - 0.5) * WORLD_HEIGHT;

                            foods.push(new Food3D(logicX, logicY, 0));
                            lastFoodTime = now;
                        }
                    }
                }
            }

            for (let i = foods.length - 1; i >= 0; i--) {
                let done = foods[i].update();
                if (done) {
                    scene.remove(foods[i].mesh);
                    foods.splice(i, 1);
                }
            }


            // Eggs (Random Spawn)
            if (Math.random() < 0.001) { // Rare
                eggs.push(new Egg3D());
            }
            for (let i = eggs.length - 1; i >= 0; i--) {
                if (handPixelPos) eggs[i].checkWarmth(handPixelPos);
                let done = eggs[i].update();
                if (done && !eggs[i].hatched) {
                    scene.remove(eggs[i].mesh);
                    eggs.splice(i, 1);
                } else if (done && eggs[i].hatched) {
                    eggs.splice(i, 1); // Already removed mesh in hatch()
                }
            }

            // Shark
            const now = Date.now();
            if (!shark && now - lastSharkTime > SHARK_SPAWN_INTERVAL && Math.random() < 0.005) {
                shark = new Shark3D();
                playSound('shark');
            }
            if (shark) {
                if (handPixelPos) {
                    shark.checkRepel(handPixelPos, handSpeed);
                }
                let done = shark.update();
                if (done) {
                    scene.remove(shark.mesh);
                    shark = null;
                    lastSharkTime = now;
                }
            }

            // Rare
            if (Math.random() < 0.003) {
                if (Math.random() < 0.5) rareAnimals.push(new Octopus3D());
                else rareAnimals.push(new Turtle3D());
                playSound('rare');
            }
            for (let i = rareAnimals.length - 1; i >= 0; i--) {
                let animal = rareAnimals[i];
                let done = animal.update();

                // Interaction
                if (!done && handPixelPos) {
                    if (checkScreenOverlap(animal.mesh, handPixelPos.x, handPixelPos.y)) {
                        if (animal instanceof Turtle3D && !animal.sparkling) {
                            animal.sparkling = true;
                            playSound('magic');
                            animal.spawnSparkle();
                        } else if (animal instanceof Octopus3D && !animal.inked) {
                            animal.inked = true;
                            playSound('pop');
                            animal.spawnInk();
                        }
                    }
                }

                if (done) {
                    scene.remove(rareAnimals[i].mesh);
                    rareAnimals.splice(i, 1);
                }
            }

            // Effects
            for (let i = effects.length - 1; i >= 0; i--) {
                let done = effects[i].update();
                if (done) {
                    effects[i].dispose();
                    effects.splice(i, 1);
                }
            }

            // Bubbles
            if (Math.random() < 0.05) {
                bubbles.push(new Bubble3D());
            }
            for (let i = bubbles.length - 1; i >= 0; i--) {
                let done = bubbles[i].update();

                // Interaction Check with Hand
                if (!done && handPixelPos) {
                    if (checkScreenOverlap(bubbles[i].mesh, handPixelPos.x, handPixelPos.y)) {
                        bubbles[i].pop();
                        done = true;
                    }
                }

                if (done) {
                    if (bubbles[i].mesh.parent) scene.remove(bubbles[i].mesh);
                    bubbles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // ==========================================
        // Sound & MediaPipe (Reused Logic)
        // ==========================================
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (!bgm) {
                bgm = new Audio('/static/images/fish/fish.mp3');
                bgm.loop = true;
                bgm.volume = 0.4;
                bgm.addEventListener('canplaythrough', () => {
                    bgm.play().catch(e => console.log('Auto-play prevented:', e));
                }, { once: true });
                bgm.load();
            } else if (bgm.paused) {
                bgm.play().catch(e => console.log('Playback:', e));
            }
        }
        window.addEventListener('click', initAudio);

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'pop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'shark') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 1.0);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now);
                osc.stop(now + 1.0);
            } else if (type === 'rare') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.5);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        // MediaPipe Setup
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (loadingElement && !loadingElement.classList.contains('hide')) {
                loadingElement.classList.add('hide');
            }
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks;
                isHandPresent = true;
            } else {
                isHandPresent = false;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        cameraUtils.start();

        // Start Three.js
        initThree();

    </script>
</body>

</html>