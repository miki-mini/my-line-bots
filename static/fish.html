<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç´„É©„Éï„É´„ÅäÈ≠ö„ÅÆ„ÅäÈÉ®Â±ãÊ∞¥ÊóèÈ§® - Fish Room Aquarium (3D)</title>
    <!-- MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            /* Dark background for video */
            font-family: 'Arial', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 10;
            text-align: center;
            text-shadow: 0 0 5px black;
        }

        .hide {
            display: none !important;
        }

        video {
            display: none;
            /* Hidden, rendered to texture or behind canvas */
        }

        /* Video background if not using texture */
        #bg-video {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            z-index: 0;
            transform: scaleX(-1);
            /* Mirror effect */
            filter: blur(4px) brightness(0.8);
        }
    </style>
</head>

<body>
    <div id="loading">üêü 3DÊ∞¥ÊóèÈ§®„ÇíÊ∫ñÂÇô‰∏≠...<br><span style="font-size:16px">„Ç´„É°„É©„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</span></div>

    <!-- Background Video Element (Rendered via CSS for performance/AR feel) -->
    <video class="input_video" id="bg-video" playsinline autoplay muted></video>

    <!-- Three.js Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Corner Decorations (Overlay) -->
    <img src="/static/images/fish/hidarisita.png"
        style="position: absolute; bottom: 0; left: 0; width: 350px; max-width: 40%; z-index: 5; pointer-events: none;"
        alt="decoration-left">
    <img src="/static/images/fish/migisita.png"
        style="position: absolute; bottom: 0; right: 0; width: 350px; max-width: 40%; z-index: 5; pointer-events: none;"
        alt="decoration-right">

    <script>
        // ==========================================
        // Constants & Setup
        // ==========================================
        const container = document.getElementById('canvas-container');
        const loadingElement = document.getElementById('loading');
        const videoElement = document.querySelector('.input_video');

        // Three.js Globals
        let scene, camera, renderer;
        let width, height;
        let clock = new THREE.Clock();

        // Game Objects
        const fishes = [];
        const bubbles = [];
        const rareAnimals = [];
        const effects = [];
        let shark = null;

        // Constants
        const NUM_FISH = 80; // Increased for 3D
        const WORLD_DEPTH = 800;
        const WORLD_WIDTH = 1200;
        const WORLD_HEIGHT = 800;

        const SHARK_SPAWN_INTERVAL = 10000;
        let lastSharkTime = 0;

        // MediaPipe
        let handLandmarks = [];
        let isHandPresent = false;
        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();


        // Audio
        let audioCtx;
        let bgm = null;

        // ==========================================
        // Assets Loading
        // ==========================================
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            shark: textureLoader.load('/static/images/fish/shark.png'),
            turtle: textureLoader.load('/static/images/fish/turtle.png'),
            turtleKira: textureLoader.load('/static/images/fish/turtle.kirakira.png'),
            octopus: textureLoader.load('/static/images/fish/octopus.png'),
            octopusSumi: textureLoader.load('/static/images/fish/octopus.sumi.png'),
        };

        // Create Fish Texture Canvas Programmatically for variety
        function createFishTexture(hue) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const color = `hsl(${hue}, 80%, 60%)`;

            // Draw fish
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(100, 32);
            ctx.lineTo(20, 10);
            ctx.lineTo(20, 54);
            ctx.closePath();
            ctx.fill();

            // Tail
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.moveTo(20, 32);
            ctx.lineTo(0, 10);
            ctx.lineTo(0, 54);
            ctx.closePath();
            ctx.fill();

            // Eye
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(80, 25, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(82, 25, 2, 0, Math.PI * 2);
            ctx.fill();

            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }


        // ==========================================
        // Three.js Initialization
        // ==========================================
        function initThree() {
            width = window.innerWidth;
            height = window.innerHeight;

            scene = new THREE.Scene();
            // Fog for depth
            scene.fog = new THREE.FogExp2(0x001020, 0.0015);

            // Camera
            camera = new THREE.PerspectiveCamera(60, width / height, 1, 2000);
            camera.position.z = 600;

            // Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(0, 500, 200);
            scene.add(dirLight);

            // Water Particles (plankton/dust)
            const particlesGeometry = new THREE.BufferGeometry();
            const particleCount = 200;
            const posArray = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 2000;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const material = new THREE.PointsMaterial({
                size: 3,
                color: 0x88ccff,
                transparent: true,
                opacity: 0.4
            });
            const particlesMesh = new THREE.Points(particlesGeometry, material);
            scene.add(particlesMesh);

            window.addEventListener('resize', onWindowResize, false);

            initFishes();
            animate();
        }

        function onWindowResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // ==========================================
        // Logic Classes
        // ==========================================

        class Vector3D {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            add(v) { this.x += v.x; this.y += v.y; this.z += v.z; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; this.z -= v.z; return this; }
            mult(n) { this.x *= n; this.y *= n; this.z *= n; return this; }
            div(n) { if (n !== 0) { this.x /= n; this.y /= n; this.z /= n; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
            normalize() {
                const m = this.mag();
                if (m !== 0) this.div(m);
                return this;
            }
            limit(max) {
                if (this.mag() > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }
            static dist(v1, v2) {
                return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2 + (v1.z - v2.z) ** 2);
            }
            copy() { return new Vector3D(this.x, this.y, this.z); }
            toThree() { return new THREE.Vector3(this.x, this.y, this.z); }
        }

        class Fish3D {
            constructor() {
                this.pos = new Vector3D(
                    (Math.random() - 0.5) * WORLD_WIDTH,
                    (Math.random() - 0.5) * WORLD_HEIGHT,
                    (Math.random() - 0.5) * WORLD_DEPTH
                );
                this.vel = new Vector3D(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
                this.acc = new Vector3D(0, 0, 0);

                this.maxSpeed = 3 + Math.random() * 2;
                this.maxForce = 0.1;
                this.size = 15 + Math.random() * 15;

                // Mesh
                const geometry = new THREE.PlaneGeometry(this.size * 2, this.size);
                const hue = Math.random() * 360;
                const texture = createFishTexture(hue);

                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            flock(boids) {
                let sep = this.separate(boids);
                let ali = this.align(boids);
                let coh = this.cohesion(boids);

                sep.mult(1.5);
                ali.mult(1.0);
                coh.mult(1.0);

                this.applyForce(sep);
                this.applyForce(ali);
                this.applyForce(coh);

                // Shark Avoidance
                if (shark) {
                    let sharkPos = new Vector3D(shark.mesh.position.x, shark.mesh.position.y, shark.mesh.position.z);
                    let flee = this.flee(sharkPos);
                    flee.mult(5.0);
                    this.applyForce(flee);
                }

                // Hand Attraction
                if (isHandPresent && handLandmarks.length > 0) {
                    // Hand is 2D, project to 3D roughly
                    // Use specific Z plane for hand interaction? e.g., z=0
                    // Mapping 0..1 to WorldCoords
                    let hx = (handLandmarks[0][8].x - 0.5) * WORLD_WIDTH; // Mirror? Hand logic needs check
                    let hy = -(handLandmarks[0][8].y - 0.5) * WORLD_HEIGHT; // Flip Y
                    let hz = 100; // Hand is "forward"

                    // Correction for mirror mode
                    hx = -hx;

                    let target = new Vector3D(hx, hy, hz);
                    let seek = this.seek(target);
                    seek.mult(2.0);
                    this.applyForce(seek);
                }
            }

            flee(target) {
                let desired = this.pos.copy().sub(target); // Away from target
                let d = desired.mag();
                if (d < 300) {
                    desired.normalize();
                    desired.mult(this.maxSpeed);
                    let steer = desired.sub(this.vel);
                    steer.limit(this.maxForce);
                    return steer;
                }
                return new Vector3D(0, 0, 0);
            }

            seek(target) {
                let desired = target.copy().sub(this.pos);
                desired.normalize();
                desired.mult(this.maxSpeed);
                let steer = desired.sub(this.vel);
                steer.limit(this.maxForce);
                return steer;
            }

            separate(boids) {
                let desiredseparation = 60.0;
                let steer = new Vector3D(0, 0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector3D.dist(this.pos, other.pos);
                    if ((d > 0) && (d < desiredseparation)) {
                        let diff = this.pos.copy().sub(other.pos);
                        diff.normalize();
                        diff.div(d);
                        steer.add(diff);
                        count++;
                    }
                }
                if (count > 0) {
                    steer.div(count);
                }
                if (steer.mag() > 0) {
                    steer.normalize();
                    steer.mult(this.maxSpeed);
                    steer.sub(this.vel);
                    steer.limit(this.maxForce);
                }
                return steer;
            }

            align(boids) {
                let neighbordist = 100;
                let sum = new Vector3D(0, 0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector3D.dist(this.pos, other.pos);
                    if ((d > 0) && (d < neighbordist)) {
                        sum.add(other.vel);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.div(count);
                    sum.normalize();
                    sum.mult(this.maxSpeed);
                    let steer = sum.sub(this.vel);
                    steer.limit(this.maxForce);
                    return steer;
                }
                return new Vector3D(0, 0, 0);
            }

            cohesion(boids) {
                let neighbordist = 100;
                let sum = new Vector3D(0, 0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector3D.dist(this.pos, other.pos);
                    if ((d > 0) && (d < neighbordist)) {
                        sum.add(other.pos);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.div(count);
                    return this.seek(sum);
                }
                return new Vector3D(0, 0, 0);
            }

            update() {
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
                this.edges();

                // Update Mesh
                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                // Rotation (Look at velocity direction)
                // atan2 for 2D, but lookAt for 3D is easier
                let lookTarget = this.mesh.position.clone().add(this.vel.toThree());
                this.mesh.lookAt(lookTarget);
                // Fix orientation (planes face +Z by default, fish texture points right?)
                // If fish texture points right (common), strict lookAt aligns -Z axis.
                // We might need to rotate geometry or adjust.
                // Let's assume lookAt works for now, might be upside down or sideways.
                // Actually lookAt makes +Z point to target. Plane is XY.
                // We'll see.
            }

            applyForce(force) {
                this.acc.add(force);
            }

            edges() {
                const W = WORLD_WIDTH / 2 + 100;
                const H = WORLD_HEIGHT / 2 + 100;
                const D = WORLD_DEPTH / 2 + 100;

                if (this.pos.x < -W) this.pos.x = W;
                if (this.pos.y < -H) this.pos.y = H;
                if (this.pos.z < -D) this.pos.z = D;

                if (this.pos.x > W) this.pos.x = -W;
                if (this.pos.y > H) this.pos.y = -H;
                if (this.pos.z > D) this.pos.z = -D;
            }
        }

        // ü¶à Shark 3D
        class Shark3D {
            constructor() {
                // Start far left or right
                this.pos = new Vector3D(-WORLD_WIDTH / 2 - 200, 0, 0);
                this.vel = new Vector3D(5, 0, 0);
                this.size = 200;

                const geometry = new THREE.PlaneGeometry(this.size * 2, this.size);
                const material = new THREE.MeshBasicMaterial({
                    map: textures.shark,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);

                // Keep upright?
                // We want shark to face movement.
            }

            update() {
                this.pos.add(this.vel);
                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                // Simple facing
                if (this.vel.x > 0) {
                    this.mesh.rotation.y = 0; // Face right
                    // My textures usually point left or right. Assuming Left?
                    // If texture points left, scaling x = -1 flips it.
                    // Let's assume texture points left (standard in my prev code?).
                    // Yes, prev code used `scale(-1, 1)` when vel.x < 0.
                    // This means default (scale 1) is facing Left.
                    // So if moving Right (vel > 0), we need scale -1 (or rotation PI).
                    this.mesh.scale.x = -1;
                } else {
                    this.mesh.scale.x = 1;
                }

                if (this.pos.x > WORLD_WIDTH / 2 + 400) return true;
                return false;
            }

            checkRepel(handPos, handVel) {
                // TBD
                return false;
            }
        }

        // üêô Octopus 3D
        class Octopus3D {
            constructor() {
                this.pos = new Vector3D(
                    (Math.random() - 0.5) * WORLD_WIDTH * 0.8,
                    -WORLD_HEIGHT / 2 - 100,
                    (Math.random() - 0.5) * WORLD_DEPTH
                );
                this.vel = new Vector3D(0, 1.0, 0); // Up
                this.size = 120;
                this.wobble = Math.random() * 100;

                const geometry = new THREE.PlaneGeometry(this.size, this.size);
                const material = new THREE.MeshBasicMaterial({
                    map: textures.octopus,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                this.pos.add(this.vel);
                this.wobble += 0.05;
                this.pos.x += Math.sin(this.wobble) * 2;

                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);
                // Billboard to camera?
                this.mesh.lookAt(camera.position);

                if (this.pos.y > WORLD_HEIGHT / 2 + 100) return true;
                return false;
            }
        }

        // üê¢ Turtle 3D
        class Turtle3D {
            constructor() {
                this.pos = new Vector3D(WORLD_WIDTH / 2 + 200, (Math.random() - 0.5) * WORLD_HEIGHT * 0.5, (Math.random() - 0.5) * 500);
                this.vel = new Vector3D(-1.5, 0, 0);
                this.size = 140;
                this.paddle = 0;

                const geometry = new THREE.PlaneGeometry(this.size, this.size);
                const material = new THREE.MeshBasicMaterial({
                    map: textures.turtle,
                    side: THREE.DoubleSide,
                    transparent: true
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                this.pos.add(this.vel);
                this.paddle += 0.1;

                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                // Tilt while swimming
                this.mesh.rotation.z = Math.sin(this.paddle) * 0.1;
                this.mesh.rotation.y = 0; // Face Left (default)

                if (this.pos.x < -WORLD_WIDTH / 2 - 200) return true;
                return false;
            }
        }

        // ü´ß Bubble 3D
        class Bubble3D {
            constructor() {
                this.pos = new Vector3D(
                    (Math.random() - 0.5) * WORLD_WIDTH,
                    -WORLD_HEIGHT / 2 - 50,
                    (Math.random() - 0.5) * WORLD_DEPTH
                );
                this.vel = new Vector3D(0, 1 + Math.random() * 2, 0);
                this.radius = 10 + Math.random() * 20;

                // Sphere Geometry for bubbles
                const geometry = new THREE.SphereGeometry(this.radius, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    shininess: 100,
                    specular: 0xffffff
                });
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }

            update() {
                this.pos.add(this.vel);
                this.pos.x += Math.sin(this.pos.y * 0.05) * 0.5;

                this.mesh.position.set(this.pos.x, this.pos.y, this.pos.z);

                if (this.pos.y > WORLD_HEIGHT / 2 + 100) return true;
                return false;
            }

            pop() {
                scene.remove(this.mesh);
                // Particle effect TBD
                playSound('pop');
            }
        }

        function initFishes() {
            for (let i = 0; i < NUM_FISH; i++) {
                fishes.push(new Fish3D());
            }
            // Start Animation Loop
            initAudio();
        }

        // ==========================================
        // Interaction Helper
        // ==========================================
        function checkScreenOverlap(mesh, cx, cy) {
            if (!mesh) return false;
            // Project 3D position to 2D screen space
            const vector = mesh.position.clone();
            vector.project(camera);

            const x = (vector.x * .5 + .5) * width;
            const y = (1 - (vector.y * .5 + .5)) * height;

            const dx = x - cx;
            const dy = y - cy;
            const d = Math.sqrt(dx * dx + dy * dy);

            return d < 80; // 80px radius interaction
        }

        function animate() {
            requestAnimationFrame(animate);

            // Hand Position in Pixels
            let handPixelPos = null;
            if (isHandPresent && handLandmarks.length > 0) {
                // MediaPipe x is 0..1 (Left..Right of image)
                let lx = handLandmarks[0][8].x;
                let ly = handLandmarks[0][8].y;

                // If we flip the video visually with css scaleX(-1),
                // we must flip the coordinate to match visual screen position.
                let sx = (1 - lx) * width;
                let sy = ly * height;
                handPixelPos = { x: sx, y: sy };
            }

            // Fish
            for (let fish of fishes) {
                fish.flock(fishes);
                fish.update();
            }

            // Shark
            const now = Date.now();
            if (!shark && now - lastSharkTime > SHARK_SPAWN_INTERVAL && Math.random() < 0.005) {
                shark = new Shark3D();
                playSound('shark');
            }
            if (shark) {
                let done = shark.update();
                if (done) {
                    scene.remove(shark.mesh);
                    shark = null;
                    lastSharkTime = now;
                }
            }

            // Rare
            if (Math.random() < 0.003) {
                if (Math.random() < 0.5) rareAnimals.push(new Octopus3D());
                else rareAnimals.push(new Turtle3D());
                playSound('rare');
            }
            for (let i = rareAnimals.length - 1; i >= 0; i--) {
                let animal = rareAnimals[i];
                let done = animal.update();

                // Interaction
                if (!done && handPixelPos) {
                    if (checkScreenOverlap(animal.mesh, handPixelPos.x, handPixelPos.y)) {
                        if (animal instanceof Turtle3D && !animal.sparkling) {
                            animal.sparkling = true;
                            playSound('magic');
                            // Simple sparkle effect visual omitted, could add later
                        } else if (animal instanceof Octopus3D && !animal.inked) {
                            animal.inked = true;
                            playSound('pop');
                        }
                    }
                }

                if (done) {
                    scene.remove(rareAnimals[i].mesh);
                    rareAnimals.splice(i, 1);
                }
            }

            // Bubbles
            if (Math.random() < 0.05) {
                bubbles.push(new Bubble3D());
            }
            for (let i = bubbles.length - 1; i >= 0; i--) {
                let done = bubbles[i].update();

                // Interaction Check with Hand
                if (!done && handPixelPos) {
                    if (checkScreenOverlap(bubbles[i].mesh, handPixelPos.x, handPixelPos.y)) {
                        bubbles[i].pop();
                        done = true;
                    }
                }

                if (done) {
                    if (bubbles[i].mesh.parent) scene.remove(bubbles[i].mesh);
                    bubbles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // ==========================================
        // Sound & MediaPipe (Reused Logic)
        // ==========================================
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (!bgm) {
                bgm = new Audio('/static/images/fish/fish.mp3');
                bgm.loop = true;
                bgm.volume = 0.4;
                bgm.addEventListener('canplaythrough', () => {
                    bgm.play().catch(e => console.log('Auto-play prevented:', e));
                }, { once: true });
                bgm.load();
            } else if (bgm.paused) {
                bgm.play().catch(e => console.log('Playback:', e));
            }
        }
        window.addEventListener('click', initAudio);

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'pop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'shark') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 1.0);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now);
                osc.stop(now + 1.0);
            } else if (type === 'rare') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.5);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        // MediaPipe Setup
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (loadingElement && !loadingElement.classList.contains('hide')) {
                loadingElement.classList.add('hide');
            }
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks;
                isHandPresent = true;
            } else {
                isHandPresent = false;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        cameraUtils.start();

        // Start Three.js
        initThree();

    </script>
</body>

</html>