<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Ç´„É©„Éï„É´„ÅäÈ≠ö„ÅÆ„ÅäÈÉ®Â±ãÊ∞¥ÊóèÈ§® - Fish Room Aquarium</title>
    <!-- MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #001020;
            font-family: 'Arial', sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 10;
            text-align: center;
        }

        .hide {
            display: none !important;
        }

        video {
            display: none;
        }
    </style>
</head>

<body>
    <div id="loading">üêü Ê∞¥ÊóèÈ§®„ÇíÊ∫ñÂÇô‰∏≠...<br><span style="font-size:16px">„Ç´„É°„É©„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</span></div>
    <video class="input_video"></video>
    <canvas class="output_canvas"></canvas>

    <!-- Corner Decorations -->
    <img src="/static/images/fish/hidarisita.png"
        style="position: absolute; bottom: 0; left: 0; width: 350px; max-width: 40%; z-index: 5; pointer-events: none;"
        alt="decoration-left">
    <img src="/static/images/fish/migisita.png"
        style="position: absolute; bottom: 0; right: 0; width: 350px; max-width: 40%; z-index: 5; pointer-events: none;"
        alt="decoration-right">

    <script>
        // ==========================================
        // Constants & Setup
        // ==========================================
        const canvas = document.querySelector('.output_canvas');
        const ctx = canvas.getContext('2d');
        const videoElement = document.querySelector('.input_video');
        const loadingElement = document.getElementById('loading');

        let width, height;
        let handLandmarks = [];
        let isHandPresent = false;

        // Game Objects
        const fishes = [];
        const bubbles = [];
        const rareAnimals = []; // Octopus, Turtle, etc.
        const effects = []; // Ink, Sparkles
        let shark = null;

        // Constants
        const NUM_FISH = 60;
        const FISH_SPEED_LIMIT = 4;
        const FISH_FORCE_LIMIT = 0.1;
        const SHARK_SPAWN_INTERVAL = 8000; // Reduced to 8 seconds
        let lastSharkTime = 0;

        // Images
        const sharkImg = new Image(); sharkImg.src = '/static/images/fish/shark.png';
        const turtleImg = new Image(); turtleImg.src = '/static/images/fish/turtle.png';
        const turtleKiraImg = new Image(); turtleKiraImg.src = '/static/images/fish/turtle.kirakira.png';
        const octopusImg = new Image(); octopusImg.src = '/static/images/fish/octopus.png';
        const octopusSumiImg = new Image(); octopusSumiImg.src = '/static/images/fish/octopus.sumi.png';

        // Audio
        const bgmSrc = '/static/images/fish/fish.mp3';

        // Audio Context (created on first interaction)
        let audioCtx;
        let bgm = null;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // ==========================================
        // Sound Engine
        // ==========================================
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Play BGM
            if (!bgm) {
                bgm = new Audio('/static/images/fish/fish.mp3');
                bgm.loop = true;
                bgm.volume = 0.4; // Slightly lower volume

                // Wait for data to be loaded to prevent freezing
                bgm.addEventListener('canplaythrough', () => {
                    bgm.play().catch(e => console.log('Auto-play prevented:', e));
                }, { once: true });

                // Fallback attempt
                bgm.load();

            } else if (bgm.paused) {
                bgm.play().catch(e => console.log('Playback failed:', e));
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'pop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'shark') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now + 1.0);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now + 1.0);
                osc.start(now);
                osc.stop(now + 1.0);
            } else if (type === 'magic') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.linearRampToValueAtTime(880, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'rare') { // Rare animal sound
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.5);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }
        window.addEventListener('click', initAudio);
        window.addEventListener('touchstart', initAudio);


        // ==========================================
        // Classes
        // ==========================================
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                const m = this.mag();
                if (m !== 0) this.div(m);
                return this;
            }
            limit(max) {
                if (this.mag() > max) {
                    this.normalize();
                    this.mult(max);
                }
                return this;
            }
            static dist(v1, v2) { return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2); }
            copy() { return new Vector(this.x, this.y); }
        }

        class Fish {
            constructor() {
                this.pos = new Vector(Math.random() * width, Math.random() * height);
                this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.acc = new Vector(0, 0);
                this.maxSpeed = FISH_SPEED_LIMIT + Math.random();
                this.maxForce = FISH_FORCE_LIMIT;
                this.color = `hsl(${Math.random() * 360}, 80%, 60%)`;
                this.size = 6 + Math.random() * 8;
            }

            flock(boids) {
                let sep = this.separate(boids);
                let ali = this.align(boids);
                let coh = this.cohesion(boids);

                sep.mult(1.5);
                ali.mult(1.0);
                coh.mult(1.0);

                this.applyForce(sep);
                this.applyForce(ali);
                this.applyForce(coh);

                // Interaction
                if (shark) {
                    let flee = this.flee(shark.pos);
                    flee.mult(5.0); // Strong fear of shark
                    this.applyForce(flee);
                } else if (isHandPresent && handLandmarks.length > 0) {
                    // Attract to first hand index finger
                    let target = new Vector(handLandmarks[0][8].x * width, handLandmarks[0][8].y * height);
                    let seek = this.seek(target);
                    seek.mult(2.0); // Strong attraction
                    this.applyForce(seek);
                }
            }

            update() {
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
                this.edges();
            }

            applyForce(force) {
                this.acc.add(force);
            }

            seek(target) {
                let desired = target.copy().sub(this.pos);
                desired.normalize();
                desired.mult(this.maxSpeed);
                let steer = desired.sub(this.vel);
                steer.limit(this.maxForce);
                return steer;
            }

            flee(target) {
                let desired = target.copy().sub(this.pos);
                let d = desired.mag();
                if (d < 300) { // Flee radius
                    desired.normalize();
                    desired.mult(this.maxSpeed);
                    desired.mult(-1); // Reverse logic to flee
                    let steer = desired.sub(this.vel);
                    steer.limit(this.maxForce);
                    return steer;
                }
                return new Vector(0, 0);
            }

            separate(boids) {
                let desiredseparation = 25.0;
                let steer = new Vector(0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector.dist(this.pos, other.pos);
                    if ((d > 0) && (d < desiredseparation)) {
                        let diff = this.pos.copy().sub(other.pos);
                        diff.normalize();
                        diff.div(d);
                        steer.add(diff);
                        count++;
                    }
                }
                if (count > 0) {
                    steer.div(count);
                }
                if (steer.mag() > 0) {
                    steer.normalize();
                    steer.mult(this.maxSpeed);
                    steer.sub(this.vel);
                    steer.limit(this.maxForce);
                }
                return steer;
            }

            align(boids) {
                let neighbordist = 50;
                let sum = new Vector(0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector.dist(this.pos, other.pos);
                    if ((d > 0) && (d < neighbordist)) {
                        sum.add(other.vel);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.div(count);
                    sum.normalize();
                    sum.mult(this.maxSpeed);
                    let steer = sum.sub(this.vel);
                    steer.limit(this.maxForce);
                    return steer;
                }
                return new Vector(0, 0);
            }

            cohesion(boids) {
                let neighbordist = 50;
                let sum = new Vector(0, 0);
                let count = 0;
                for (let other of boids) {
                    let d = Vector.dist(this.pos, other.pos);
                    if ((d > 0) && (d < neighbordist)) {
                        sum.add(other.pos);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.div(count);
                    return this.seek(sum);
                }
                return new Vector(0, 0);
            }

            edges() {
                if (this.pos.x < -this.size) this.pos.x = width + this.size;
                if (this.pos.y < -this.size) this.pos.y = height + this.size;
                if (this.pos.x > width + this.size) this.pos.x = -this.size;
                if (this.pos.y > height + this.size) this.pos.y = -this.size;
            }

            draw() {
                let angle = Math.atan2(this.vel.y, this.vel.x);
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(angle);

                // Draw fish
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.size * 2, 0);
                ctx.lineTo(-this.size, -this.size);
                ctx.lineTo(-this.size, this.size);
                ctx.closePath();
                ctx.fill();

                // Tail
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(-this.size, 0);
                ctx.lineTo(-this.size * 2, -this.size);
                ctx.lineTo(-this.size * 2, this.size);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        class Shark {
            constructor() {
                this.pos = new Vector(-300, Math.random() * (height - 200) + 100);
                this.vel = new Vector(3, 0);
                this.size = 120; // Larger for image
                this.fleeing = false;
            }

            update() {
                this.pos.add(this.vel);
                if (this.pos.x > width + 300 && !this.fleeing) {
                    return true; // Shark finished pass
                }
                if (this.fleeing) {
                    this.vel.x += 0.5; // Accelerate away
                    if (this.pos.x > width + 300 || this.pos.x < -300) return true;
                }
                return false;
            }

            checkRepel(handPos, handVel) {
                if (!handPos) return;
                let d = Vector.dist(this.pos, new Vector(handPos.x * width, handPos.y * height));
                if (d < 250 && handVel > 20) { // If close and hand moving fast
                    this.fleeing = true;
                    this.vel.x *= -1.5; // Turn around and speed up
                    playSound('shark');
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                if (this.vel.x < 0) ctx.scale(-1, 1);

                // Draw Shark Image
                // Center the image
                if (sharkImg.complete) {
                    ctx.drawImage(sharkImg, -this.size, -this.size / 2, this.size * 2, this.size);
                } else {
                    // Fallback
                    ctx.fillStyle = "gray";
                    ctx.beginPath();
                    ctx.arc(0, 0, 50, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // üêô Octopus Class
        class Octopus {
            constructor() {
                this.pos = new Vector(Math.random() * width, height + 100);
                this.vel = new Vector(0, -0.8); // Moves up slowly
                this.size = 80;
                this.wobble = Math.random() * 100;
                this.inked = false;
            }

            update() {
                this.pos.add(this.vel);
                this.wobble += 0.1;
                this.pos.x += Math.sin(this.wobble) * 1.5; // Sway side to side

                if (this.pos.y < -100) return true; // Gone off top
                return false;
            }

            checkInteract(handPos) {
                if (this.inked || !handPos) return;
                let d = Vector.dist(this.pos, new Vector(handPos.x * width, handPos.y * height));
                if (d < this.size + 20) {
                    this.inked = true;
                    // Spawn Ink
                    effects.push(new Ink(this.pos.x, this.pos.y));
                    playSound('pop'); // Reuse pop or specific sound?
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);

                // Draw Octopus Image
                if (octopusImg.complete) {
                    ctx.drawImage(octopusImg, -this.size / 2, -this.size / 2, this.size, this.size);
                }

                ctx.restore();
            }
        }

        // üê¢ Turtle Class
        class Turtle {
            constructor() {
                this.pos = new Vector(width + 100, Math.random() * (height - 200) + 100);
                this.vel = new Vector(-1, 0); // Moves left slowly
                this.size = 90;
                this.paddleAngle = 0;
                this.sparkling = false;
                this.sparkleTimer = 0;
            }

            update() {
                this.pos.add(this.vel);
                this.paddleAngle += 0.1;

                if (this.sparkling) {
                    this.sparkleTimer--;
                    if (this.sparkleTimer <= 0) {
                        this.sparkling = false;
                    }
                }

                if (this.pos.x < -100) return true; // Gone off left
                return false;
            }

            checkInteract(handPos) {
                if (!handPos) return;
                let d = Vector.dist(this.pos, new Vector(handPos.x * width, handPos.y * height));
                if (d < this.size) {
                    this.sparkling = true;
                    this.sparkleTimer = 60; // 1 second approx
                    playSound('magic');
                    // Spawn Sparkles
                    for (let i = 0; i < 10; i++) {
                        effects.push(new Sparkle(this.pos.x, this.pos.y));
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);

                // Draw Turtle Image
                let img = this.sparkling ? turtleKiraImg : turtleImg;

                if (img.complete) {
                    // Adding slight rotation for swim effect
                    ctx.rotate(Math.sin(this.paddleAngle) * 0.1);
                    ctx.drawImage(img, -this.size / 2, -this.size / 2, this.size, this.size);
                }

                ctx.restore();
            }
        }

        // ‚ú® Sparkle Effect
        class Sparkle {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = new Vector((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4);
                this.alpha = 1.0;
                this.size = Math.random() * 5 + 5;
            }
            update() {
                this.pos.add(this.vel);
                this.alpha -= 0.02;
                return this.alpha <= 0;
            }
            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = "#FFD700"; // Gold
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                // Shine cross
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-this.size * 1.5, 0); ctx.lineTo(this.size * 1.5, 0);
                ctx.moveTo(0, -this.size * 1.5); ctx.lineTo(0, this.size * 1.5);
                ctx.stroke();
                ctx.restore();
            }
        }

        // üå´Ô∏è Ink Effect
        class Ink {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.alpha = 1.0;
                this.size = 100;
                this.expand = 1.0;
            }
            update() {
                this.alpha -= 0.01;
                this.expand += 0.5;
                return this.alpha <= 0;
            }
            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.globalAlpha = this.alpha;
                if (octopusSumiImg.complete) {
                    ctx.drawImage(octopusSumiImg, -this.size / 2 - this.expand / 2, -this.size / 2 - this.expand / 2, this.size + this.expand, this.size + this.expand);
                }
                ctx.restore();
            }
        }

        class Bubble {
            constructor() {
                this.pos = new Vector(Math.random() * width, height + 20);
                this.vel = new Vector(0, -(1 + Math.random() * 2));
                this.radius = 10 + Math.random() * 20;
            }

            update() {
                this.pos.add(this.vel);
                // Wiggle
                this.pos.x += Math.sin(this.pos.y * 0.05) * 0.5;
            }

            checkPop(handPos) {
                if (!handPos) return false;
                let d = Vector.dist(this.pos, new Vector(handPos.x * width, handPos.y * height));
                if (d < this.radius + 15) { // 15 is approx finger radius
                    playSound('pop');
                    return true;
                }
                return false;
            }

            isOffScreen() {
                return this.pos.y < -50;
            }

            draw() {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                // Shine
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.beginPath();
                ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ==========================================
        // Main Loop
        // ==========================================
        function init() {
            for (let i = 0; i < NUM_FISH; i++) {
                fishes.push(new Fish());
            }
            animate();
        }

        // Previous hand position for velocity
        let prevHandPos = null;
        let handVelocity = 0;

        function animate(timestamp) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Background (Video Feed + Blue Tint)
            ctx.save();
            ctx.filter = "blur(4px)";
            // Mirror image
            ctx.translate(width, 0);
            ctx.scale(-1, 1);
            ctx.globalAlpha = 0.6; // Video opacity
            ctx.drawImage(videoElement, 0, 0, width, height);
            ctx.restore();

            // Underwater Overlay
            ctx.fillStyle = "rgba(0, 30, 80, 0.4)";
            ctx.fillRect(0, 0, width, height);

            // Calculate Hand Velocity
            handVelocity = 0;
            if (isHandPresent && handLandmarks.length > 0) {
                let currentPos = handLandmarks[0][8]; // Index finger tip
                if (prevHandPos) {
                    let dx = (currentPos.x - prevHandPos.x) * width;
                    let dy = (currentPos.y - prevHandPos.y) * height;
                    handVelocity = Math.sqrt(dx * dx + dy * dy);
                }
                prevHandPos = currentPos;
            } else {
                prevHandPos = null;
            }

            // 2. Fish Logic
            for (let fish of fishes) {
                fish.flock(fishes);
                fish.update();
                fish.draw();
            }

            // 3. Shark Logic
            if (!shark && timestamp - lastSharkTime > SHARK_SPAWN_INTERVAL && Math.random() < 0.005) {
                playSound('shark');
                shark = new Shark();
            }
            if (shark) {
                if (isHandPresent && handLandmarks.length > 0) {
                    shark.checkRepel(handLandmarks[0][8], handVelocity);
                }
                let restart = shark.update();
                shark.draw();
                if (restart) {
                    shark = null;
                    lastSharkTime = timestamp;
                }
            }

            // 3.5 Rare Animals Logic
            if (Math.random() < 0.002) { // Small chance each frame
                if (Math.random() < 0.5) {
                    rareAnimals.push(new Octopus());
                    playSound('rare');
                } else {
                    rareAnimals.push(new Turtle());
                    playSound('rare');
                }
            }
            for (let i = rareAnimals.length - 1; i >= 0; i--) {
                let animal = rareAnimals[i];
                // Interaction Check
                if (isHandPresent && handLandmarks.length > 0) {
                    animal.checkInteract(handLandmarks[0][8]); // Index finger
                }

                let done = animal.update();
                animal.draw();
                if (done) {
                    rareAnimals.splice(i, 1);
                }
            }

            // 3.6 Effects Logic
            for (let i = effects.length - 1; i >= 0; i--) {
                let done = effects[i].update();
                effects[i].draw();
                if (done) effects.splice(i, 1);
            }

            // 4. Bubble Logic
            if (Math.random() < 0.03) {
                bubbles.push(new Bubble());
            }
            for (let i = bubbles.length - 1; i >= 0; i--) {
                bubbles[i].update();
                bubbles[i].draw();

                let popped = false;
                if (isHandPresent && handLandmarks.length > 0) {
                    // Check index, thumb, middle
                    let fingers = [4, 8, 12]; // Tip indices
                    for (let tipIdx of fingers) {
                        if (bubbles[i] && bubbles[i].checkPop(handLandmarks[0][tipIdx])) {
                            popped = true;
                            break;
                        }
                    }
                }

                if (popped || bubbles[i].isOffScreen()) {
                    bubbles.splice(i, 1);
                }
            }

            // 5. Hand Visuals (Optional - Magic dust?)
            if (isHandPresent && handLandmarks.length > 0) {
                let tip = handLandmarks[0][8];
                ctx.fillStyle = "rgba(255, 255, 200, 0.5)";
                ctx.beginPath();
                ctx.arc(tip.x * width, tip.y * height, 10, 0, Math.PI * 2);
                ctx.fill();
            }

            requestAnimationFrame(animate);
        }

        init();
        // ==========================================
        // MediaPipe Hands Setup
        // ==========================================
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        function onResults(results) {
            loadingElement.classList.add('hide');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandPresent = true;
                // Normalize coordinates handling mirroring (MediaPipe gives 0-1, we mirrored canvas but logic uses 0-1)
                // Note: video is drawn mirrored.
                // MediaPipe landmarks: x is 0-1.
                // If we draw video mirrored, visual left is x=1, visual right is x=0?.
                // Actually, let's keep logic simple:
                // We draw video with ctx.scale(-1, 1). So x=0 in video pixel is drawn at width.
                // MediaPipe x coordinate matches the video source texture.
                // To match the mirrored visual, we need to flip x.

                handLandmarks = results.multiHandLandmarks.map(hand => {
                    return hand.map(pt => {
                        return { x: 1 - pt.x, y: pt.y, z: pt.z }; // Flip X for mirrored feel
                    });
                });
            } else {
                isHandPresent = false;
                handLandmarks = [];
            }
        }

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        camera.start();


    </script>
</body>

</html>